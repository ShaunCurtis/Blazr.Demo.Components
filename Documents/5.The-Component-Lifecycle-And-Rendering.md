# The Component Lifecycle and the Rendering

## The Component Lifecycle

The component liefcycle is managed by the Renderer.  You have no control over the actual lifecycle.  You can't instanciate a component and pass it to the renderer.

1. The component is instanciated and the `new()` is run.  The ctor method is often overlooked.  At this point the parameters are in their default state and there's no `RenderHandle`.

2. The Renderer calls `Attach` and passes in a `RenderHandle`.  This is the component's communications medium with the Renderer.  Save it to an internal field.

3. The Renderer calls `SetParametersAsync` and passes in a `ParameterView` object.  This is the object the Renderer uses to manage the component's parameters.  This should be used in `SetParametersAsync` and then released.  Don't save it to an internal field.

4. The Renderer calls `SetParametersAsync` whenever it detects that the components parameters "may have changed".

5. If the component implements `IDisposable` or `IAsyncDisposable`, it calls it and then de-references the component.  The GC will then destroy the redundant object.

## The Render Process

Let's look in detail at how a simple page and component get rendered.

**MinimalComponent.razor**
```csharp
@inherits MinimalBase

<div class="@CssClass">
    <h3>MinimalComponent</h3>
    <h4>Rendered at @(DateTime.Now.ToLongTimeString())</h4>
    <h5>@(Uid.ToString())</h5>
</div>

@code {
    [Parameter] public bool Hidden { get; set; }
    [Parameter] public string CssClass { get; set; } = string.Empty;
    private Guid Uid = Guid.NewGuid();
    protected override bool shouldHide => this.Hidden;
}
```

#### SimplePage.razor
```csharp
@page "/simple"
<h3>SimplePage</h3>
@if (loaded)
{
    <SimpleComponent></SimpleComponent>
}
else
{
    <div class="h4 bg-danger text-white p-2">Loading.....</div>
}

@code {
    private bool loaded;

    protected async override Task OnInitializedAsync()
    {
        await Task.Delay(2000);
        loaded = true;
    }
}
```

The follow diagram shows a simplified `RenderTree` representing a simple "/" route.

![Root Render Tree](https://shauncurtis.github.io/articles/assets/Blazor-Components/Root-Render-Tree.png)

Note the three nodes in `NavMenu` for the three `NavLink` controls. 

On our page, the render tree looks like the diagram below on first render - we have a yielding `OnInitializedAsync` method, so `StateHasChanged` gets run in the initialization process.

![Simple Page Loading](https://shauncurtis.github.io/articles/assets/Blazor-Components/Simple-Page-Loading.png)

Once initialization completes, `StateHasChanged` is run a second time.  `Loaded` is now `true` and `SimpleComponent` is added to the component `RenderFragment`.  When the `Renderer` runs the `RenderFragment`, `SimpleComponent` is added to the render tree, instantiated and initialized.

![Simple Page Loaded](https://shauncurtis.github.io/articles/assets/Blazor-Components/Simple-Page-Loaded.png)

### Component Content

Change `SimpleComponent` and `SimplePage` to:

#### SimpleComponent.razor
```csharp
<div class="h4 bg-success text-white p-2">@ChildContent</div>

@code {
    [Parameter] public RenderFragment ChildContent { get; set; }
}
```

#### SimplePage.razor
```csharp
@page "/simple"
<h3>SimplePage</h3>
@if (loaded)
{
    <SimpleComponent>
        <button class="btn btn-primary" @onclick="ButtonClick">Click Me</button>
    </SimpleComponent>
}
else
{
    <div class="h4 bg-danger text-white p-2">Loading.....</div>
}

@code {
    private bool loaded;

    protected async override Task OnInitializedAsync()
    {
        await Task.Delay(2000);
        loaded = true;
    }

    protected void ButtonClick(MouseEventArgs e)
    {
        var x = true;
    }
}
```
There is now content in `SimpleComponent`. When the application is run that content gets executed in the context of the parent component.  How?

The answer is in `SimpleComponent`.   Remove the `[Parameter]` attribute from `SimpleComponent` and run the page.  It errors:

```Text
InvalidOperationException: Object of type 'xxx.SimpleComponent' has a property matching the name 'ChildContent', but it does not have [ParameterAttribute] or [CascadingParameterAttribute] applied.
```

If a component has "content" i.e. markup between the opening and closing tags, Blazor expects to find a `Parameter` named `ChildContent` in the component.  The content between the tags is pre-compiled into a `RenderFragment` and then added to the component.  The content of the `RenderFragment` is run in the context of the object that owns it - `SimplePage`.

The content can also be defined like this:

```html
<SimpleComponent>
    <ChildContent>
        <button class="btn btn-primary" @onclick="ButtonClick">
            Click Me
        </button>
    </ChildContent>
</SimpleComponent>
```

The page can also be re-written as below, where it now becomes more obvious who owns the `RenderFragment`.

```csharp
@page "/simple"
<h3>SimplePage</h3>
@if (loaded)
{
    <SimpleComponent>
        @_childContent
    </SimpleComponent>
}
else
{
    <div class="h4 bg-danger text-white p-2">Loading.....</div>
}

@code {

    private bool loaded;

    protected async override Task OnInitializedAsync()
    {
        await Task.Delay(2000);
        loaded = true;
    }

    protected void ButtonClick(MouseEventArgs e)
    {
        var x = true;
    }

    private RenderFragment _childContent => (builder) =>
    {
        builder.OpenElement(0, "button");
        builder.AddAttribute(1, "class", "btn btn-primary");
        builder.AddAttribute(2, "onclick", EventCallback.Factory.Create<MouseEventArgs>(this, ButtonClick));
        builder.AddContent(3, "Click Me");
        builder.CloseElement();
    };
}
```

A component is not limited to a single `RenderFragment`.  A table component could look like this:

```html
<TableComponent>
    <Header>
        ...
    </Header>
    <Rows>
        ...
    </Rows>
    <Footer>
        ...
    </Footer>
</TableComponent>
```

## Component Events

Hidden away are two important interfaces that dictate how components react to UI events.

 - `IHandleEvent`
 - `IHandleAfterRender`

#### IHandleEvent

When the Renderer receives a UI event it checks the compoment to see if it implements `IHandleEvent`.  If so then it passes the call to the handler.

`IHandleEvent` defines the following single method.

```csharp
Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, object? arg);
```

`ComponentBase` implements the interface, with the two step call to `StateHasChanged`.

```csharp
Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, object? arg)
{
    var task = callback.InvokeAsync(arg);
    var shouldAwaitTask = task.Status != TaskStatus.RanToCompletion &&
        task.Status != TaskStatus.Canceled;

    // After each event, we synchronously re-render (unless !ShouldRender())
    // This just saves the developer the trouble of putting "StateHasChanged();"
    // at the end of every event callback.
    StateHasChanged();

    return shouldAwaitTask ?
        CallStateHasChangedOnAsyncCompletion(task) :
        Task.CompletedTask;
}

private async Task CallStateHasChangedOnAsyncCompletion(Task task)
{
    try
    {
        await task;
    }
    catch // avoiding exception filters for AOT runtime support
    {
        // Ignore exceptions from task cancellations, but don't bother issuing a state change.
        if (task.IsCanceled)
            return;
        throw;
    }
    StateHasChanged();
}
```

If `IHandleEvent` is not implemented it simply calls the handler directly.

```csharp
Task async IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, object? arg)
   => await callback.InvokeAsync(arg);
```

#### IHandleAfterRender

When the component completes rendering the Renderer checks the compoment to see if it implements `IHandleAfterRender`.  If so then it passes the call to the handler.

`ComponentBase` implements the interface.

```csharp
Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, object? arg)
{
    var task = callback.InvokeAsync(arg);
    var shouldAwaitTask = task.Status != TaskStatus.RanToCompletion &&
        task.Status != TaskStatus.Canceled;

    // After each event, we synchronously re-render (unless !ShouldRender())
    // This just saves the developer the trouble of putting "StateHasChanged();"
    // at the end of every event callback.
    StateHasChanged();

    return shouldAwaitTask ?
        CallStateHasChangedOnAsyncCompletion(task) :
        Task.CompletedTask;
}
```

If `IHandleAfterRender` is not implemented then nothing happens.

```csharp
Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, object? arg)
   => return Task.CompletedTask;
```

#### Void UI Events

The following code won't execute as expected in `ComponentBase`:

```csharp
void async ButtonClick(MouseEventArgs e) 
{
  await Task.Delay(2000);
  UpdateADisplayProperty();
}
```

The DisplayProperty doesn't display the current value until another `StateHasChanged` events occurs.  Why? ButtonClick doesn't return anything, so there's no `Task` for the event handler to wait on.  On the `await` yield, it runs to completion running the final `StateHasChanged` before `UpdateADisplayProperty` completes.

This is a band-aid fix - it's bad pactice, **DON'T DO IT**.

```csharp
void async ButtonClick(MouseEventArgs e) 
{
  await Task.Delay(2000);
  UpdateADisplayProperty();
  StateHasChanged();
}
```

The correct solution is:

```csharp
Task async ButtonClick(MouseEventArgs e) 
{
  await Task.Delay(2000);
  UpdateADisplayProperty();
}
```
Now the event handler has a `Task` to await and doesn't execute `StateHasChanged` until `ButtonClick` completes.

## Some Important Less Documented Information and Lessons Learned

### Keep Parameter Properties Simple

Your parameter declarations should look like this:

```csharp
[Parameter] MyClass myClass {get; set;}
```

**DON'T** add code to the getter or setter.  Why?  Any setter must be run as part of the render process and can have a significant impact on render speed and component state.

### Overriding SetParametersAsync

If you override `SetParametersAsync` your method should look like this: 

``` csharp
    public override Task SetParametersAsync(ParameterView parameters)
    {
        // always call first
        parameters.SetParameterProperties(this);
        // Your Code
        .....
        // pass an empty ParameterView, not parameters
        return base.SetParametersAsync(ParameterView.Empty);
    }
```

Set the parameters in the first line and call the base method passing `ParameterView.Empty`.  Don't try to pass `parameters` - you will get an error.

### Parameters as Immutable

Never set Parameters in your code.  If you want to make or track changes do this:

```csharp
    [Parameter] public int MyParameter { get; set; }
    private int _MyParameter;
    public event EventHandler MyParameterChanged;

    public async override Task SetParametersAsync(ParameterView parameters)
    {
        parameters.SetParameterProperties(this);
        if (!_MyParameter.Equals(MyParameter))
        {
            _MyParameter = MyParameter;
            MyParameterChanged?.Invoke(_MyParameter, EventArgs.Empty);
        }
        await base.SetParametersAsync(ParameterView.Empty);
    }
```

### Iterators

A common problem occurs when a `For` iterator is used to loop through a collection to build a `select` or a data table.  A typical example is shown below:

```csharp
@for (var counter = 0; counter < this.myList.Count; counter++)
{
    <button class="btn btn-dark m-3" @onclick="() => ButtonClick(this.myList[counter])">@this.myList[counter]</button>
}
@for (var counter = 0; counter < this.myList.Count; counter++)
{
    <button class="btn btn-dark m-3" @onclick="() => ButtonClick(counter)">@this.myList[counter]</button>
}
<div>Value = @this.value </div>

@code {
    private List<int> myList => new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    private int value;

    private Task ButtonClick(int value)
    {
        this.value = value;
        return Task.CompletedTask;
    }
}
```

If you click on a button in the first row, you will get a *Index was out of range* error.  Click on a button in the second row and value is always 10.  The reason is that the interator has completed before you click a button, at which time `counter` is 10.

To fix the problem, set a local variable within the loop as shown below.

```csharp
@for (var counter = 0; counter < this.myList.Count; counter++)
{
    var item = this.myList[counter];
    <button class="btn btn-dark m-3" @onclick="() => ButtonClick(item)">@item</button>
}
@for (var counter = 0; counter < this.myList.Count; counter++)
{
    var item = this.myList[counter];
    var thiscount = counter;
    <button class="btn btn-info m-3" @onclick="() => ButtonClick(thiscount)">@item</button>
}
```

The best solution is to use `ForEach`.

```csharp
@foreach  (var item in this.myList)
{
    <button class="btn btn-primary m-3" @onclick="() => ButtonClick(item)">@item</button>
}
```
### Component Numbering

It's seems logical to use iterators to automate the numbering of component elements.  DON'T.  The numbering system is used by the diffing engine to decide which bits of the DOM need updating and which bits don't.  Numbering must be consistent within a `RenderFragment`.  You can use `OpenRegion` and `CloseRegion` to define a region with it's own number space.  [See this gist for a more detailed explanation](https://gist.github.com/SteveSandersonMS/ec232992c2446ab9a0059dd0fbc5d0c3). 

## Building Components

Components can be defined in three ways:
1. As a *.razor* file with an code inside an *@code* block.
2. As a *.razor* file and a code behind *.razor.cs* file.
3. As a pure *.cs* class file inheriting from *ComponentBase* or a *ComponentBase* inherited class, or implementing *IComponent*.

##### All in One Razor File

HelloWorld.razor

```html
<div>
@HelloWorld
</div>

@code {
[Parameter]
public string HelloWorld {get; set;} = "Hello?";
}
```

##### Code Behind

HelloWorld.razor

```html
@inherits ComponentBase
@namespace CEC.Blazor.Server.Pages

<div>
@HelloWorld
</div>
```
HelloWorld.razor.cs

```csharp
namespace CEC.Blazor.Server.Pages
{
    public partial class HelloWorld : ComponentBase
    {
        [Parameter]
        public string HelloWorld {get; set;} = "Hello?";
    }
}
```

##### C# Class

HelloWorld.cs

```csharp
namespace CEC.Blazor.Server.Pages
{
    public class HelloWorld : ComponentBase
    {
        [Parameter]
        public string HelloWorld {get; set;} = "Hello?";

        protected override void BuildRenderTree(RenderTreeBuilder builder)
        {
            builder.OpenElement(0, "div");
            builder.AddContent(1, (MarkupString)this._Content);
            builder.CloseElement();
        }
    }
}
```

## Inheritance

If you are creating abstract components from `ComponentBase` don't override `OnInitialized{Async}` and `OnParametersSet{Async}` in the abstract classes with your custom code.  This presents a timing problem: do you run `base.OnInitializedAsync` at the start or end of `this.OnInitializedAsync`.

Lets look an example.  We have a `ViewRecordComponent<TRecord>` that loads a record as part of the initilization.  The best way to implement this is to override `SetParametersAsync` and add a `LoadRecordAsync` method to the core lifecycle sequence.  Here's what the code could look like:

```csharp
public async override Task SetParametersAsync(ParameterView parameters)
{
    parameters.SetParameterProperties(this);
    await this.LoadRecordAsync();
    await base.SetParametersAsync(ParameterView.Empty);
}

protected virtual Task LoadRecordAsync()
{
    // load code
}
```

You've coded exactly when `LoadRecordAsync` is run.

## Some Observations

1. There's a tendency to pile too much code into `OnInitialized` and `OnInitializedAsync` and then use events to drive `StateHasChanged` updates in the component tree.  Get the relevant code into the right places in the lifecycle and you won't need the events.

2. There's a temptation to start with the non-async versions (because they're easier to implement) and only use the async versions when you have to, when the opposite should be true.  Most web based activities are inherently async in nature.  I never use the non-async versions - I work on the principle that at some point I'm going to need to add async behaviour.
   
3. `StateHasChanged` is called far to often, normally because code is in the wrong place in the component lifecycle, or the events have been coded incorrectly.  Ask yourself a challenging "Why?" when you type `StateHasChanged`.

4. Components are underused in the UI.  The same code/markup blocks are used repeatedly.  The same rules apply to code/markup blocks as to C# code.

5. Once you really, REALLY understand components, writing Blazor code becomes a totally "different" experience.
   