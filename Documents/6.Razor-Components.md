# A Deep Dive into the Blazor Component

## Razor Components

Most components are defined in Razor.  But what's the relationship between a Razor component and `IComponent`?

There isn't one.  The only requirement for a Razor component is that the defined inherited class must implement:

```csharp
protected virtual void BuildRenderTree(RenderTreeBuilder builder);
```

The Razor compiler overrides `BuildRenderTree` with a method containing the `RenderTreeBuilder` code that represents the component's UI.

If no inheritance is defined, it sets the compiled class to inherit from `ComponentBase`.

Here's a simple abstract class which defines `BuilRenderTree`:

```csharp
public abstract class RazorClass
{
    protected abstract void BuildRenderTree(RenderTreeBuilder builder);

    public RenderFragment Content => (builder) => BuildRenderTree(builder);
}
```

A Razor Implementation:

```csharp
// Div.razor
@inherits RazorClass

<h3>My Razor Class Div</h3>
```

And it's usage in a page:

```csharp
@(new Div().Content)
```

### Building Render Fragments

There are two ways to build render fragments.

Firstly we can use the RenderTreeBuilder.  This is how the Razor compiler builds a class from a Razor component file. 

```csharp
@inherits RazorClass

@HelloWorld

@code {
    protected RenderFragment HelloWorld => (RenderTreeBuilder builder) =>
    {
        builder.OpenElement(0, "div");
        builder.AddContent(1, "Hello Razor 2");
        builder.CloseElement();
    };
}
```

We're defining a `RenderFragment` property and assigning an anonymous method to it that conforms to the `RenderFragment` pattern.  It takes a  `RenderTreeBuilder` and has no return so returns a void.  It uses the provided `RenderTreeBuilder` object to build the content: a simple hello world html div.  Each call to the builder adds what is called a `RenderTreeFrame`.  Note each frame is sequentially numbered.

Or like this:

```csharp
@inherits MinimalBase

@HelloWorld

@code {
    protected RenderFragment HelloWorld => (RenderTreeBuilder builder) =>
    {
        <div>Hello Blazor 3</div>
    };
}
```

Here we're mixing C# code and markup.  The Razor compiler recognises this and compiles the code correctly.

It's important to understand two points:
1. The component itself never "runs" the `RenderFragement`.  It is passed to the Renderer which Invokes it.
2. Even though the `Renderer` invokes the code, the code is run in the context of the component, and the state of the component when executing happens.

We can take the concept above and just define a class.

```csharp
public class DivClass : MinimalBase
{
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        builder.OpenElement(0, "div");
        builder.AddContent(1, "Hello Razor 2");
        builder.CloseElement();
    }
}
```

### Routed Components

Everything's a component, but not all components are equal.  **Routed Components** are a little special.

They contain *@page* routing directives and optionally a *@Layout* directive.

```html
@page "/WeatherForecast"
@page "/WeatherForecasts"
@layout MainLayout
```

You can define these directly on classes like this:

```csharp
[LayoutAttribute(typeof(MainLayout))]
[RouteAttribute("/helloworld")]
public class RendererComponent : IComponent {}
```

The `RouteAttribute` is used by the router to find Routes in the application.

Don't think of routed components as pages. It may seem obvious to do so, but don't.  Lots of web page properties don't apply to routed components.  You will:
 - get confused when routed components don't behave like a page.
 - try and code the component logic as if it is a web page.

