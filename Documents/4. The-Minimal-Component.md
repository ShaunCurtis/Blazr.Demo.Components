# The Minimal Component

In the introduction we saw a very minimal component.  In this chapter we turn it into a fully functional

Our first pass is to:

1. Capture and save the `RenderHandle`.
2. Render the component whenever `SetParametersAsync` is called.
3. Provide the virtual method for the Razor compiler to override.
4. Make it `abstract` as this is a base class. 

```csharp
public abstract class Minimal1Base : IComponent
{
    protected RenderHandle? renderHandle;

    public void Attach(RenderHandle handle)
        => renderHandle = handle;

    public Task SetParametersAsync(ParameterView parameters)
    {
        // Sets the component parameters to the latest values
        parameters.SetParameterProperties(this);
        // Creates a render fragment as an anonymous function that calls BuildRenderTree
        RenderFragment fragment = (builder) => BuildRenderTree(builder);
        // passes the fragment to the RenderTree to render
        this.renderHandle?.Render(fragment);
        return Task.CompletedTask;
    }

    protected abstract void BuildRenderTree(RenderTreeBuilder builder);
}
```

Our simplest Hello World Razor component looks like this:

```html
@inherits RazorClass
<h3>Hello Blazor</h3>
```


## Improving `MinimalBase`

This code isn't a very efficient way of implementing the component render fragment:

```csharp
RenderFragment fragment = (builder) => BuildRenderTree(builder);
```

The runtime has to build the anonymous function every time the component renders.  We can cache this is ctor like this.

First some state fields:

```csharp
    protected RenderHandle renderHandle;
    private bool _renderPending;
    private RenderFragment _componentFragment;
    protected virtual bool shouldHide { get; set; }
```

We create the anonymous method in the ctor.  Remember, this is the code the Render runs.  `shouldRender` provides an efficient way to show/hide the component code.  

```csharp
    public MinimalBase()
    {
        _componentFragment = (builder) =>
        {
            _renderPending = false;
            if (!this.shouldHide)
                BuildRenderTree(builder);
        };
    }
```
We can also improve the render code.  The existing code places the render fragment in the queue regardless of whether there's already one queued.

```csharp
this.renderHandle.Render(fragment);
```

The new method uses a private `bool` `_renderPending` to track render state.  If the component render fragment is already queued, it doesn't add another one, the one already in the queue will render the component with the current changes.

```csharp
protected void RequestRender()
{
    if (!_renderPending)
    {
        _renderPending = true;
        this.renderHandle.Render(_componentFragment);
    }
}
```
The final base component is:

```csharp
public abstract class MinimalBase : IComponent
{
    protected RenderHandle renderHandle;
    private bool _renderPending;
    private RenderFragment _componentFragment;
    protected virtual bool shouldHide { get; set; }
   
    public MinimalBase()
    {
        _componentFragment = (builder) =>
        {
            _renderPending = false;
            if (!this.shouldHide)
                BuildRenderTree(builder);
        };
    }

    public void Attach(RenderHandle handle)
        => renderHandle = handle;

    public Task SetParametersAsync(ParameterView parameters)
    {
        parameters.SetParameterProperties(this);
        this.RequestRender();
        return Task.CompletedTask;
    }

    protected abstract void BuildRenderTree(RenderTreeBuilder builder);

    protected void RequestRender()
    {
        if (!_renderPending)
        {
            _renderPending = true;
            this.renderHandle.Render(_componentFragment);
        }
    }
}
```

To demonstrate it in action here's a simple fully functional Bootstrap UI Components:

**BootstrapAlert**
```csharp
@inherits MinimalBase

<div class="alert @this.Colour">@this.Message</div>

@code {
    protected override bool shouldHide => this.Hidden;

    [Parameter] public bool Hidden { get; set; }
    [Parameter] public string Colour { get; set; } = "alert-primary";
    [Parameter] public string Message { get; set; } = "Bootstrap Alert";
}
```
**BootstrapButton**

```csharp
@inherits MinimalBase

<button class="btn @this.Colour" @onclick=this.Clicked >@this.Text</button>

@code {
    protected override bool shouldHide => this.Hidden;

    [Parameter] public bool Hidden { get; set; }
    [Parameter] public string Colour { get; set; } = "btn-primary";
    [Parameter] public string Text { get; set; } = "Button";
    [Parameter] public EventCallback<MouseEventArgs> Clicked { get; set; }
}
```

And a test page:

```csharp
@page "/"
@inherits MinimalBase

<BootstrapAlert Hidden=this.hidden Message="Hello Blazor" />

<BootstrapButton Colour="btn-primary" Text="Update" Clicked=this.Clicked />

@code {
    private bool hidden;

    private void Clicked()
    {
        this.hidden = !this.hidden;
        this.RequestRender();
    }
}
```
